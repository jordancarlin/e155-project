[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU",
    "section": "",
    "text": "The multicore processor in this project is used to keep track of the current brush state, the color state, the thickness of the brush, and whether the brush is up or down. The system collects this data and then sends it to the FPGA board for VGA processing via a SPI package. There are two primary SPI packages used to communicate the status of bits, and they are organized such that the header of the color SPI block is easily distinguished and decoded.\n\n\nThe MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\nThe hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly.\n\n\n\n\nWe are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "mcu.html#schematic",
    "href": "mcu.html#schematic",
    "title": "MCU",
    "section": "",
    "text": "The MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "mcu.html#hardware",
    "href": "mcu.html#hardware",
    "title": "MCU",
    "section": "",
    "text": "The hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly."
  },
  {
    "objectID": "mcu.html#current-status",
    "href": "mcu.html#current-status",
    "title": "MCU",
    "section": "",
    "text": "We are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "appendices.html",
    "href": "appendices.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "MCU (User Guide | Reference Manual)\nFPGA (Lattice Semiconductor Board)\nE155 Supplied Boards (Development Board | Adapter Board)\n\nZoe Worrall Lab Writeups (Lab 1 | Lab 2 | Lab 3 | Lab 4 | Lab 5 | Lab 6 | Lab 7)\n\n\n\n\n\n\n\nImage of Clock Tree\n\n\n\n\n\n\nFigure 13 in the MCU Reference Manual\n\n\n\nDetails on Proficiency and Excellency Specs:\nProficiency: [] Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\n[] System operates without any major bugs (e.g., doesn’t freeze in operation)\n[] Document listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\n[] Technical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\n[] Verilog HDL is functional and cleanly formatted\n[] MCU C code is functional and cleanly formatted\nExcellency: Project meets all the specifications as laid out in the proposal. Project is polished (e.g., wires are hidden, any physical interfaces are well-designed and reliable, clean user interface) Verilog code is efficient and demonstrates best coding practices (e.g., modularity, testbenches were appropriate, etc.) C code is efficient and well organized (e.g., code encapsulated in functions and custom libraries as appropriate)\n\nhttps://hmc-e155.github.io/final-project-portfolio/"
  },
  {
    "objectID": "appendices.html#hardware-tools",
    "href": "appendices.html#hardware-tools",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "MCU (User Guide | Reference Manual)\nFPGA (Lattice Semiconductor Board)\nE155 Supplied Boards (Development Board | Adapter Board)\n\nZoe Worrall Lab Writeups (Lab 1 | Lab 2 | Lab 3 | Lab 4 | Lab 5 | Lab 6 | Lab 7)\n\n\n\n\n\n\n\nImage of Clock Tree\n\n\n\n\n\n\nFigure 13 in the MCU Reference Manual\n\n\n\nDetails on Proficiency and Excellency Specs:\nProficiency: [] Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\n[] System operates without any major bugs (e.g., doesn’t freeze in operation)\n[] Document listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\n[] Technical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\n[] Verilog HDL is functional and cleanly formatted\n[] MCU C code is functional and cleanly formatted\nExcellency: Project meets all the specifications as laid out in the proposal. Project is polished (e.g., wires are hidden, any physical interfaces are well-designed and reliable, clean user interface) Verilog code is efficient and demonstrates best coding practices (e.g., modularity, testbenches were appropriate, etc.) C code is efficient and well organized (e.g., code encapsulated in functions and custom libraries as appropriate)\n\nhttps://hmc-e155.github.io/final-project-portfolio/"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "Our initial goal for this project was to achieve the following:\n\nBuild a system that is able to draw using a joystick controller\nAllow analog input that allows the user to chose between 7 colors\nGive the user control of a brush’s width (i.e. configure some sort of thickness for the brush)\nAllow the user to pick the brush “off the page” while drawing\nStretch Goal A countdown timer that updates every second\n\nOf these initial goals, we achieved enough for efficiency, but were unable to meet our final specs for the countdown timer. Particularly because of the short at the end, during demo day it was additionally impossible to provide user input.\nIf the project was to be summed in terms of percentage, the following estimates should be made:\n[60%] Transmitting from RAM of the FPGA to a VGA Monitor [15%] Generating, Transmitting, and Receiving Data via SPI from the MCU to the FPGA board [10%] Assigning buttons and anlog pins, and updating SPI for sending to the FPGA [10%] Inclusion of a countdown timer [5%] Additional graphics and presentation of the piece\nOverall, we achieved almost all of our goals, and reached likely 90% of what we wanted to achieve in this project.\n\n\n\n\nThe MCU of the Micro P(ictionary) game used the SystemClock (which runs at 4 MHz) for all calculations.\nThe analog to digital converter on the MCU relies on the output of the AHB Clock. For further details, view the linked clock tree image in the Appendix. This clock ran at at the SystemClock’s speed during this project. A new set of modules, STM32L432KC_ADC.c and STM32L432KC_ADC.h, were constructed in order to make for easy initialization of any new ADC pins. The conversion rate of analog to digital signals the data was not integral to the performance of the system, as we did not anticipate that user input would be changing faster than 10 Hz within a given second.\nThe main timing constraint on the MCU side was the control of the sending rate of the SPI. The device is set up to send a new SPI update every 500 ms, based on Timer 12 of the MCU. Because the FPGA would immediately update as soon as it receives its new X and Y direction, the “send rate” of the FPGA also determines the speed with which someone could move the brush on the screen. It was found that the ideal speed to move the brush was 500 ms, but if desired in the future it may be possible to add a potentiometer that increases or decreases the pause time between each update to the brush’s location."
  },
  {
    "objectID": "results.html#quantitative-results",
    "href": "results.html#quantitative-results",
    "title": "Results",
    "section": "",
    "text": "Our initial goal for this project was to achieve the following:\n\nBuild a system that is able to draw using a joystick controller\nAllow analog input that allows the user to chose between 7 colors\nGive the user control of a brush’s width (i.e. configure some sort of thickness for the brush)\nAllow the user to pick the brush “off the page” while drawing\nStretch Goal A countdown timer that updates every second\n\nOf these initial goals, we achieved enough for efficiency, but were unable to meet our final specs for the countdown timer. Particularly because of the short at the end, during demo day it was additionally impossible to provide user input.\nIf the project was to be summed in terms of percentage, the following estimates should be made:\n[60%] Transmitting from RAM of the FPGA to a VGA Monitor [15%] Generating, Transmitting, and Receiving Data via SPI from the MCU to the FPGA board [10%] Assigning buttons and anlog pins, and updating SPI for sending to the FPGA [10%] Inclusion of a countdown timer [5%] Additional graphics and presentation of the piece\nOverall, we achieved almost all of our goals, and reached likely 90% of what we wanted to achieve in this project.\n\n\n\n\nThe MCU of the Micro P(ictionary) game used the SystemClock (which runs at 4 MHz) for all calculations.\nThe analog to digital converter on the MCU relies on the output of the AHB Clock. For further details, view the linked clock tree image in the Appendix. This clock ran at at the SystemClock’s speed during this project. A new set of modules, STM32L432KC_ADC.c and STM32L432KC_ADC.h, were constructed in order to make for easy initialization of any new ADC pins. The conversion rate of analog to digital signals the data was not integral to the performance of the system, as we did not anticipate that user input would be changing faster than 10 Hz within a given second.\nThe main timing constraint on the MCU side was the control of the sending rate of the SPI. The device is set up to send a new SPI update every 500 ms, based on Timer 12 of the MCU. Because the FPGA would immediately update as soon as it receives its new X and Y direction, the “send rate” of the FPGA also determines the speed with which someone could move the brush on the screen. It was found that the ideal speed to move the brush was 500 ms, but if desired in the future it may be possible to add a potentiometer that increases or decreases the pause time between each update to the brush’s location."
  },
  {
    "objectID": "results.html#qualitative-results",
    "href": "results.html#qualitative-results",
    "title": "Results",
    "section": "Qualitative Results",
    "text": "Qualitative Results\n\nAnalog Pins\nThe MCU’s use of analog pins was done extremely quickly, in large part thanks to much of the previous work done by past students in Micro P’s. We found the following two sources particularly helpful:\n\nCamera by Kavi Dey, Henry Merrilees, and Neil Chulani\n\nDigital Synthesizer by Kevin Box and Eli Rejto\n\nThe analog pins were capable of measuring the voltage output of the joystick and the potentiometer. It appeared that, especially towards the end, that there were conflicts between the sampled data for x, y, and t, wherein one of the values would always be high even if it was not meant to. The analog output of the pins normally measured their input voltage times 1000 when measured correctly; 3.3 volts as a result appeared as 3300 on the board, for example.\n\n\nSPI\n\nWe planned on sending and receiving two potential SPI packets : either a color bit packet, or a location packet. The color packet was encoded such that it contained configuration bits 111 at the beginning, which could never be reached by x or y since they exceeded the array range being used (Figure 1 and Figure 2).\n\n\n\n\n\n\n\nFigure 1: The bits of color SPI package.\n\n\n\n\n\n\n\n\n\nFigure 2: The bits of the location SPI package.\n\n\n\n\nThe system was confirmed to be transmitting via SPI early on during the Mid-semester check-in:\n\n\n\n\n\n\n\n\n\n\n\nWe needed to confirm that the FPGA was properly reaching its desired states based on the incoming SPI packets. This was confirmed using oscilloscope probes attached to the incoming SCK, MOSI, and CS channels.\nIn a method similar to that seen in the following images, various states that the FPGA was able to decipher and use to define its state variables.\nAll channels are encoded such that Channel 1 is CS, Channel 2 is MOSI, and Channel 3 is SCK.\n\n\n\n\n\n\n\nFigure 3: This image confirms that the SPI packets are carrying accurate data (i.e. the location of the brush) to the FPGA.\n\n\n\n\n\n\n\n\n\nFigure 4: This image uses channel 4, the dark blue channel, to confirm that we were properly reaching a “ready” state within our FSM block diagram. This was set to be true based on the MOSI signal, which it can be seen to match the MOSI signal on Channel 2\n\n\n\n\n\n\nVGA\nThe final system was able to put the brush up and down, change its color, and move about the screen. Implementation was still being made to change the bit size using the potentiometer, however this was halted by the MCU no longer being able to connect to JLink when connected to the Adapter board.\nThe final system is able to consistently update and change depending on the color and pin inputs. As can be seen in Figure 5, the system was able to create and draw the systems.\n\n\n\n\n\n\nFigure 5: An image depicting our system creating drawings on the screen via the MCU to FPGA communication.\n\n\n\nThe following are multiple videos that were taken while troubleshooting and moving our systems into the real world.\nFirst, we the system was able to print to the VGA system at a single pixel by directly setting the index of a given array. This system, as we later discovered using the Netlist feature in Lattice Radiant, did not use RAM. We started by setting all the values outside of our grid (128x128 pixels) pink.\n\n\nAbove is a video of our planned designated screen on the design with the outline of our block.\n\nAfter this, we began trying to set the values according to what we had received via wx and wy. We confirmed the wx and wy were correct in simulation (?@fig-workingSim) by confirming that when wx and wy were at a set value, for example 100 and 100, and set to 0'b001 (encoding for red), the RAM was recording that value. This was confirmed within the MemoryList feature of ModelSim.\n::: \nVideo displaying how we were able to finally get some things printing on the FPGA using setting parameters in Lattice Radiant. :::\nHowever, while printing we ran into an issue; the RAM was not being correctly indexed by the system. It was only possible to alter pixels directly using an address in the matrix.\n::: \nA video of trying to read while setting bits according to whats stored in the wx and wy bits at a specific section; these bits should be the color that is stored for a specific location, but when they are sent into the array they don’t update correctly, resulting in the oscillating pattern seen above. :::\nThis can be seen in the following video (?@fig-video2), where we tried to set the data within the file to wx and wy while reading out the values. The User Guide specified that the RAM that we were attempting to use was “pseudo dual”, but didn’t specify what this meant.\nAs a result, we moved onto using SPRAM instead. SPRAM required that we doubled the clock speed, but at the same time permitted for better contorl of what we were sending and receiving to the screen. This is where we began to see results.\n:::  :::\nThe video above is a demonstration of color being transmitted correctly. With the confirmation of SPI working, we were able to confirm that we should be updating colors correctly, and with this video we confirmed with certainty that the SPI was able to receive. Our next steps involved filling the entire screen with this data rather than just the noise present in this video.\n:::  :::\nThe video above was confirmation that we could control every bit we wanted to using a write x and y of our choosing. From there, it was a very quick fix to begin moving the pixels about the board with details sent using the other package for xy bits."
  },
  {
    "objectID": "results.html#the-build",
    "href": "results.html#the-build",
    "title": "Results",
    "section": "The Build",
    "text": "The Build\nOur Final project was made using several bread boards, as well as several printed components that give it a finished look.\nThe joystick was soldered onto a small protoboard to prevent noise and avoid messy wiring.\nAll seven buttons were put onto a separate bread board to ensure proper circuitry, and were wired in long distance to prevent complex wiring.\nThe switch and the potentiometer were both free floating, but have been given housing that provides easy control for the user when the design is working."
  },
  {
    "objectID": "results.html#final-updates",
    "href": "results.html#final-updates",
    "title": "Results",
    "section": "Final Updates",
    "text": "Final Updates\nZoe managed to break the Dev board while confused, meaning that MCU’s can no longer connect to JLink on the current board.\nThis means that the system can not currently print designs, even though they were confirmed to have been working as expected in the past. Planned future updates include moving to a different Dev board just to see if that fixes the issue."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA",
    "section": "",
    "text": "The FPGA controls drives a VGA monitor and stores the image to be displayed on the monitor. It recieves SPI packets from the MCU (see MCU description for an explanation of the packets) that specify what changes need to be made to the image. The current image is stored in block ram on the FPGA. As SPI packets are received, there is a block of logic on the FPGA that checks what type of data the packet contains and, if necessary, updates certain pixels in the block ram accordingly.\nThe FPGA also has a block of sequential to drive the actual VGA display that scans through each pixel in the block ram and sends the appropriate RGB values to the VGA monitor. The pixels are stores in a 3 bit encoding format (one value for each of the 7 colors supported by the system) and a decoder is used to convert these values to the actual RGB values for the VGA monitor. The playable area of the screen is 200x200 pixels, so the block ram only contains values for those pixels.\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new) and the use of block ram to store the image is also similar to storing the sbox encoding in Lab 7 (though this one needs to be a writable ram instead of just a pre-loaded rom). The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly indepenent thing, the use of the block ram makes that impossible for this project. The VGA driver needs to be able to read from the block ram, while the SPI decoder needs to write to it. Additionally, the VGA module isn’t even able to directly output the RGB values to the monitor becaue they need to be looked up in the block ram and then decoded. This means the VGA module sends most of the VGA signals out to the monitor, but send the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\nOne of the tricky parts of the hardware design for the FPGA was utilizing block ram to store the pixel array. There were many attempts to tweak the verilog to get the synthesis tool to infer the appropriate block ram hardware. As seen in Figure 3, this was eventually successful and it is utilizing a block ram that reads combinationally (though is sequenced by a flop) and writes sequentially on the rising edge of the clock. The write enable line also had to be connected to data recieved from the SPI packets to ensure pixels were only updated when the pen was down.\n\n\n\n\n\n\nFigure 3\n\n\n\nThe other main aspect of the hardware design is the actual VGA interface. Figure 4 shows the high-level interace between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\n\nA second version of all of the Verilog is written and (almost) passing synthesis. The inital version that was designed had to scrapped because the hierarchy and interfaces between each module were woefully insufficient. A new block diagram (Figure 1) was created with a far shallower hierarchy to allow for more communication between modules. The old design for the pixel array was also not being detected properly as a RAM. The current version is being detected as a block RAM with the expected read, write, and enable ports.\nThe current design passes the first few stages of synthesis, but is currently running into issues with place and route and with timing. The timing issues likely stem from clock issues becasue the SPI sck needs to drive some of the design while the VGA vgaclk needs to drive other parts of it. Using multiple clocks is far from ideal, but is necessary because of the strict timing requirements for VGA monitors. The place and route issues likely stem from the timing problems, but it is not possible to know for sure until the timing issues are resolved.\nThe other part of the FPGA process that is currently underway is verification of the design. Testbenches are in their early stage of creation and will be used to verify the SPI half of the design and the VGA half of the design separately. Depending on how those go, a full system testbench will likely be created to verify the entire design."
  },
  {
    "objectID": "fpga.html#block-diagram",
    "href": "fpga.html#block-diagram",
    "title": "FPGA",
    "section": "",
    "text": "Figure 1\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new) and the use of block ram to store the image is also similar to storing the sbox encoding in Lab 7 (though this one needs to be a writable ram instead of just a pre-loaded rom). The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly indepenent thing, the use of the block ram makes that impossible for this project. The VGA driver needs to be able to read from the block ram, while the SPI decoder needs to write to it. Additionally, the VGA module isn’t even able to directly output the RGB values to the monitor becaue they need to be looked up in the block ram and then decoded. This means the VGA module sends most of the VGA signals out to the monitor, but send the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "fpga.html#hardware",
    "href": "fpga.html#hardware",
    "title": "FPGA",
    "section": "",
    "text": "One of the tricky parts of the hardware design for the FPGA was utilizing block ram to store the pixel array. There were many attempts to tweak the verilog to get the synthesis tool to infer the appropriate block ram hardware. As seen in Figure 3, this was eventually successful and it is utilizing a block ram that reads combinationally (though is sequenced by a flop) and writes sequentially on the rising edge of the clock. The write enable line also had to be connected to data recieved from the SPI packets to ensure pixels were only updated when the pen was down.\n\n\n\n\n\n\nFigure 3\n\n\n\nThe other main aspect of the hardware design is the actual VGA interface. Figure 4 shows the high-level interace between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 4"
  },
  {
    "objectID": "fpga.html#current-status",
    "href": "fpga.html#current-status",
    "title": "FPGA",
    "section": "",
    "text": "A second version of all of the Verilog is written and (almost) passing synthesis. The inital version that was designed had to scrapped because the hierarchy and interfaces between each module were woefully insufficient. A new block diagram (Figure 1) was created with a far shallower hierarchy to allow for more communication between modules. The old design for the pixel array was also not being detected properly as a RAM. The current version is being detected as a block RAM with the expected read, write, and enable ports.\nThe current design passes the first few stages of synthesis, but is currently running into issues with place and route and with timing. The timing issues likely stem from clock issues becasue the SPI sck needs to drive some of the design while the VGA vgaclk needs to drive other parts of it. Using multiple clocks is far from ideal, but is necessary because of the strict timing requirements for VGA monitors. The place and route issues likely stem from the timing problems, but it is not possible to know for sure until the timing issues are resolved.\nThe other part of the FPGA process that is currently underway is verification of the design. Testbenches are in their early stage of creation and will be used to verify the SPI half of the design and the VGA half of the design separately. Depending on how those go, a full system testbench will likely be created to verify the entire design."
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Meet the Team",
    "section": "",
    "text": "email:   jcarlin@g.hmc.edu \n\n\nJordan Carlin is a junior engineering major at Harvey Mudd College interested in computer engineering and digital design. He is currently doing research as a Clay-Wolkin Fellow at Harvey Mudd’s VLSI lab working on a superscalar implementation of the open-source OpenHW-Group CVW RISC-V SoC. He has experience with SystemVerilog and RISC-V assembly and would love to continue growing his computer engineering skills. He’s always excited to learn new things and would be happy to connect with you!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n LinkedIn \n\n\n\n GitHub \n\n\n Website \n\n\n OpenHW Github"
  },
  {
    "objectID": "team.html#jordan-carlin",
    "href": "team.html#jordan-carlin",
    "title": "Meet the Team",
    "section": "",
    "text": "email:   jcarlin@g.hmc.edu \n\n\nJordan Carlin is a junior engineering major at Harvey Mudd College interested in computer engineering and digital design. He is currently doing research as a Clay-Wolkin Fellow at Harvey Mudd’s VLSI lab working on a superscalar implementation of the open-source OpenHW-Group CVW RISC-V SoC. He has experience with SystemVerilog and RISC-V assembly and would love to continue growing his computer engineering skills. He’s always excited to learn new things and would be happy to connect with you!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n LinkedIn \n\n\n\n GitHub \n\n\n Website \n\n\n OpenHW Github"
  },
  {
    "objectID": "team.html#zoe-worrall",
    "href": "team.html#zoe-worrall",
    "title": "Meet the Team",
    "section": "Zoe Worrall",
    "text": "Zoe Worrall\n\n email:   zworrall@g.hmc.edu \n\nMae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Micro P’s Website \n\n\n\n LinkedIn \n\n\n\n GitHub"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Micro P(ictionary)",
    "section": "",
    "text": "Welcome to MicroP(ictionary)!\nThis design project sought to create a Pictionary device using an Upduino FPGA board and an STM432KCU4 MCU board. Pictionary is a game that allows a user to control an on screen brush to “draw” on a screen. The user is able to manipulate the brush’s size, color, and location in order to draw whatever designs they want on a screen. To provide this for the users, this project supplied a system of seven buttons for color, a potentiometer to control the size of the brush, a switch to control whether the brush was up or down, and a joystick to control the brush’s location on the screen.\nThis system uses an MCU and an FPGA board to control a VGA monitor. The MCU reads 11 real-time inputs from a user, including both analog and digital signals, and sends SPI packages to the FPGA board. The FPGA board interprets the incoming SPI packages, and uses them to manipulate a brush on the VGA screen using a set of digital to analog converters to control red, green, and blue signals.\n\n\n\n\n\n\nFigure 1: This is the block diagram of what the system looks like from top down.\n\n\n\nThe device was capable of drawing on the screen by the end of the project time limit. It had also previously demonstrated its ability to draw, and control if the brush was up or down, using the inputs of the MCU controller. This was captured in a photograph (Figure 2)\n\n\n\n\n\n\nFigure 2: A photograph captured of the working Micro P(ictionary) program. The user was able to pick the brush up and place it down, change color and size of the brush, and move the brush to the desired locations on the screen.\n\n\n\nHowever, roughly an hour before check off, while trying to move analog parts and reconfigure them to prevent some of the noise being seen in the circuit, part of the board was shorted out. As a result, last minute changes needed to be made in order to demonstrate the screen to others. This code removed the ability to input data into the MCU, and randomly generated signals which were then sent to the VGA display using the same encoding as would have applied for analog circuitry. This was dubbed a “glorified screensaver” for observers.\n\n\n\n\n\n\nFigure 3: Video of the glorified screen saver while running for Demo Day. Uses the same communication and decoding methods as the initial function, but there is a randomly generated set of code being sent on the MCU.\n\n\n\nThe Github included in this report has two branches: the main, which contains the current FPGA and MCU code for what was used in order to get the device actually functioning before the board was shorted, and a side branch that demonstrates what was shown during the device’s Demo Day.\nThis report will detail\n\nDetails on the layout of the MCU\n\nDetails on the layout of the FPGA\n\nDetails on the hardware\n\nDetails on results\n\nDetails on the team behind this project"
  },
  {
    "objectID": "index.html#brief",
    "href": "index.html#brief",
    "title": "Micro P(ictionary)",
    "section": "",
    "text": "Welcome to MicroP(ictionary)!\nThis design project sought to create a Pictionary device using an Upduino FPGA board and an STM432KCU4 MCU board. Pictionary is a game that allows a user to control an on screen brush to “draw” on a screen. The user is able to manipulate the brush’s size, color, and location in order to draw whatever designs they want on a screen. To provide this for the users, this project supplied a system of seven buttons for color, a potentiometer to control the size of the brush, a switch to control whether the brush was up or down, and a joystick to control the brush’s location on the screen.\nThis system uses an MCU and an FPGA board to control a VGA monitor. The MCU reads 11 real-time inputs from a user, including both analog and digital signals, and sends SPI packages to the FPGA board. The FPGA board interprets the incoming SPI packages, and uses them to manipulate a brush on the VGA screen using a set of digital to analog converters to control red, green, and blue signals.\n\n\n\n\n\n\nFigure 1: This is the block diagram of what the system looks like from top down.\n\n\n\nThe device was capable of drawing on the screen by the end of the project time limit. It had also previously demonstrated its ability to draw, and control if the brush was up or down, using the inputs of the MCU controller. This was captured in a photograph (Figure 2)\n\n\n\n\n\n\nFigure 2: A photograph captured of the working Micro P(ictionary) program. The user was able to pick the brush up and place it down, change color and size of the brush, and move the brush to the desired locations on the screen.\n\n\n\nHowever, roughly an hour before check off, while trying to move analog parts and reconfigure them to prevent some of the noise being seen in the circuit, part of the board was shorted out. As a result, last minute changes needed to be made in order to demonstrate the screen to others. This code removed the ability to input data into the MCU, and randomly generated signals which were then sent to the VGA display using the same encoding as would have applied for analog circuitry. This was dubbed a “glorified screensaver” for observers.\n\n\n\n\n\n\nFigure 3: Video of the glorified screen saver while running for Demo Day. Uses the same communication and decoding methods as the initial function, but there is a randomly generated set of code being sent on the MCU.\n\n\n\nThe Github included in this report has two branches: the main, which contains the current FPGA and MCU code for what was used in order to get the device actually functioning before the board was shorted, and a side branch that demonstrates what was shown during the device’s Demo Day.\nThis report will detail\n\nDetails on the layout of the MCU\n\nDetails on the layout of the FPGA\n\nDetails on the hardware\n\nDetails on results\n\nDetails on the team behind this project"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "Micro P(ictionary)",
    "section": "Abstract",
    "text": "Abstract\nMicroP(ictionary) is a game for lab students that want to play online, but have to play using hardware instead. The goal of this project was to make a Micro P(ictionary) game with the following specs:\n\n7 Buttons to control 7 different colors\n\n\nA potentiometer to control the thickness of the brush being used\n\n\nA brush up/down switch that controls whether the brush is drawing or not\n\n\nA joystick to control where we are on the board.\n\nThe project had two separate pieces; the MCU that collects and stores the current status of the brush (including color, thickness, and location), and the FPGA, which has an onboard RAM that stores the color left behind by the brush or simply shows the user their current location. The brush will always be orange. The MCU consistently sends SPI updates of the location of the user to the FPGA board, and the FPGA board then outputs this data onto the computer screen. When the user updates the colors of the board or decides to put the brush down, the system sends an additional SPI package with the updated color and brush up/down information.\nThis program was extremely close to working, but likely due to a high level of power flux, the board connection between the MCU and the FPGA has been shorted. The MCU can be connected to via JLink separate from the board, but when it is plugged into the board, JLink can no longer connect.\nPrior to this issue, the device was able to draw x/y locations, as well as travel in a controlled manner about the screen.\nA video prior to this was not captured demonstrating how the brush was able to travel about the screen and leave a trail: this video, however, displays how the brush’s current color was being captured and making it over to the VGA device, and how control of whether the color was changed via the brush up/down switch was changed.\n\nThe overview of this system can be seen in Figure 1."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Breaking down this design from the top down, the system takes user input, processes it within the MCU, and then updates the FPGA with the brush’s current location and any updated color settings using SPI. The entire 128x128 grid used for drawing is stored on the FPGA within its RAM memory, and the SPI updates are used in order to read into the device and write out. Depending on if the brush is raised or lowered, the FPGA will follow different logic; when the brush moves, it will either leave the previous color behind, or it will update the color with the current color selected by the brush.\n\n\n\n\n\n\nFigure 1: Simplified Block diagram of the system’s interconnects.\n\n\n\nPrior to completing the entire design, we figured out what pins could be used on the MCU board to determine exactly how many colors and controls we could have. We started by figuring out which pins we would use for the SPI, as those were on the Development Board used in E155. We found that with our current break-out board, and with the assumption that the colors would be set using interrupt controls, we could use seven pins off of the MCU. We further determined which three pins we could use for analog input, and assigned our final pin for brush up and brush down using our remaining set of pins.\nThe FPGA board’s pins were routed based off of the number of pins necessary to control the VGA’s red, blue, and green channels, as well as whether the V-Sync and H-Sync of the VGA was on or off. For further details on how VGA works, see further details in the FPGA Section or this website.\nThis design resulted in the following overall schematic for the board interconnects (Figure 2), although further details and decisions can be found in the MCU Section and the FPGA Section.\n\n\n\n\n\n\nFigure 2: Detailed schematic diagram of hardware used within the project."
  },
  {
    "objectID": "documentation.html#schematics",
    "href": "documentation.html#schematics",
    "title": "Documentation",
    "section": "",
    "text": "Breaking down this design from the top down, the system takes user input, processes it within the MCU, and then updates the FPGA with the brush’s current location and any updated color settings using SPI. The entire 128x128 grid used for drawing is stored on the FPGA within its RAM memory, and the SPI updates are used in order to read into the device and write out. Depending on if the brush is raised or lowered, the FPGA will follow different logic; when the brush moves, it will either leave the previous color behind, or it will update the color with the current color selected by the brush.\n\n\n\n\n\n\nFigure 1: Simplified Block diagram of the system’s interconnects.\n\n\n\nPrior to completing the entire design, we figured out what pins could be used on the MCU board to determine exactly how many colors and controls we could have. We started by figuring out which pins we would use for the SPI, as those were on the Development Board used in E155. We found that with our current break-out board, and with the assumption that the colors would be set using interrupt controls, we could use seven pins off of the MCU. We further determined which three pins we could use for analog input, and assigned our final pin for brush up and brush down using our remaining set of pins.\nThe FPGA board’s pins were routed based off of the number of pins necessary to control the VGA’s red, blue, and green channels, as well as whether the V-Sync and H-Sync of the VGA was on or off. For further details on how VGA works, see further details in the FPGA Section or this website.\nThis design resulted in the following overall schematic for the board interconnects (Figure 2), although further details and decisions can be found in the MCU Section and the FPGA Section.\n\n\n\n\n\n\nFigure 2: Detailed schematic diagram of hardware used within the project."
  },
  {
    "objectID": "documentation.html#new-hardware",
    "href": "documentation.html#new-hardware",
    "title": "Documentation",
    "section": " New Hardware ",
    "text": "New Hardware \n\nMicro P(ictionary) is built using the FPGA and MCU programming techniques and skills learned throughout Mudd’s E155 course, with several new hardware and software components.\n\n Joystick \nFor the MCU, alongside the interrupts and SPI outputs from previous labs, a new analog functionality was the included in order to allow for joystick control and the use of a potentiometer for brush size. The joystick that we chose outputs an analog voltage for x and y on two different pins; depending on the incoming voltage, the joystick will output half the voltage in its middle state, 0 in its lowest, and the full applied voltage at its highest. In our design, we powered the joystick under its required supply voltage of 5 V at 3.3 V, meaning that when powered, the joystick would output about 1.7 V at medium power, 3.3 V at max (either positive X or Y), and 0 V for lowest power (either negative X or Y). Each analog input need to be read into the MCU using the onboard ADCs and then filtered to give us usable data to determine the desired position for the brush. The same idea applied for the potentiometer.\n\n\n VGA  (Video Graphics Array) \nThe other significant new hardware component is the VGA monitor. This required lots of new components of the FPGA. First of all, the PLL clock on the board was needed to generate the clock signal to produce the H-Sync and V-Sync signals for the monitor. This also required the use of a much larger RAM (an SPRAM in this case) to store the color data for each pixel. This RAM in particular was the source of many of our troubles throughout this project.\nThe VGA requires an analog input to all three pins used for color (i.e. R-G-B pins). This meant that in addition to the code that was constructed in Lattice Radiant, we needed to make a physical digital to analog (DAC) converter, with seven resistors used for each channel.\n\n\nAdditional Hardware Information\nFor more details on the hardware, see the MCU and FPGA pages. These include schematics and block diagrams.\nThe Github repository contains all of the source code for the project.\nRelevant links for more information can be found in the Appendix.\nThis project has a relatively low barrier of entry from a hardware perspective. If you are working from a well stocked lab, the only parts that are not likely present the joystick and a VGA breadboard adapter."
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\n\n\n\n\n\n\nItem\nPart Number\nQuantity\nTotal Price\n\n\n\n\nVGA Adapter\nVGA DB15\n1\n$7.39\n\n\nJoystick\nKY-023\n5\n$6.49\n\n\nVGA Monitor\nAny\n1\nDigital Lab\n\n\n[DIP Button]\nSPST-NO\n1\nStockroom\n\n\n[DIP Switch]\n782-3831-5-ND\n1\nStockroom\n\n\n[10 kOhm] Potentiometer\nAlpha B10k\n1\nStockroom\n\n\n[DIP Switch]\n72N3906\n1\nStockroom"
  }
]