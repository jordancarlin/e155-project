[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU",
    "section": "",
    "text": "The multicore processor in this project is used to keep track of the current brush state, the color state, the thickness of the brush, and whether the brush is up or down. The system collects this data and then sends it to the FPGA board for VGA processing via a SPI packet. There are two primary SPI packets used to communicate the status of bits, and they are organized such that the header of the color SPI block is easily distinguished and decoded.\n\n\nThe MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s. It uses interrupts in order to assign the brush’s current color, with a total of seven potential colors (including erase).\nThe system also implements the newer technology of analog to digital conversion (ADC) on the MCU, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\nWhen compiled together, this gives Figure 1. The detailed layout of the pins can be found in the dropdown containing Figure 2.\n\n\n\n\n\n\nFigure 1: Broad overview of the MCU device, detailing which inputs are digital and which are analog.\n\n\n\n\n\n\n\n\n\nDiagram of all Pin-outs on the MCU\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nEach of the buttons and the analog control of the joystick has an op-amp attached to it. This was done while breadboarding, as significant loading was noted specifically on the part of the joystick. The op-amps were added to the buttons as an extreme precautionary measure, although this was likely unnecessary.\n\n\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some 500 ms, before calling read_XY to find the current state of the joystick and to update the size of the brush. This information is used to determine what SPI packets are sent at the end of the while loop. In the case that an interrupt has occurred or the switch controlling whether or not the brush has been raised or lowered has changed, color_spi is updated.\nThe behavior of interrupts is depicted in Figure 3.\n\n\n\n\n\n\nFigure 3: Depiction of how interrupts interact with the current system, specifically how they assign just_set and adjust the color of the SPI.\n\n\n\nThe block diagram below (Figure 4) depicts the general variables and assignments used within the MCU program. An even more generalized view can be found in Figure 5.\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\n\nThe program is able to send out all the locations necessary dependent on the current thickness of the brush. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given time.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI packets are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the byte greater than 200, which is impossible for the x and y indices to be. As a result, the SPI packets can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly.\nThe video below is a demonstration of the data being sent out of the MCU at any given time."
  },
  {
    "objectID": "mcu.html#schematic",
    "href": "mcu.html#schematic",
    "title": "MCU",
    "section": "",
    "text": "The MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s. It uses interrupts in order to assign the brush’s current color, with a total of seven potential colors (including erase).\nThe system also implements the newer technology of analog to digital conversion (ADC) on the MCU, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\nWhen compiled together, this gives Figure 1. The detailed layout of the pins can be found in the dropdown containing Figure 2.\n\n\n\n\n\n\nFigure 1: Broad overview of the MCU device, detailing which inputs are digital and which are analog.\n\n\n\n\n\n\n\n\n\nDiagram of all Pin-outs on the MCU\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nEach of the buttons and the analog control of the joystick has an op-amp attached to it. This was done while breadboarding, as significant loading was noted specifically on the part of the joystick. The op-amps were added to the buttons as an extreme precautionary measure, although this was likely unnecessary.\n\n\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some 500 ms, before calling read_XY to find the current state of the joystick and to update the size of the brush. This information is used to determine what SPI packets are sent at the end of the while loop. In the case that an interrupt has occurred or the switch controlling whether or not the brush has been raised or lowered has changed, color_spi is updated.\nThe behavior of interrupts is depicted in Figure 3.\n\n\n\n\n\n\nFigure 3: Depiction of how interrupts interact with the current system, specifically how they assign just_set and adjust the color of the SPI.\n\n\n\nThe block diagram below (Figure 4) depicts the general variables and assignments used within the MCU program. An even more generalized view can be found in Figure 5.\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\n\n\n\n\nFigure 5"
  },
  {
    "objectID": "mcu.html#spi",
    "href": "mcu.html#spi",
    "title": "MCU",
    "section": "",
    "text": "The program is able to send out all the locations necessary dependent on the current thickness of the brush. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given time.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI packets are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the byte greater than 200, which is impossible for the x and y indices to be. As a result, the SPI packets can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly.\nThe video below is a demonstration of the data being sent out of the MCU at any given time."
  },
  {
    "objectID": "appendices.html",
    "href": "appendices.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "MCU (User Guide | Reference Manual)\n\n\n\nFPGA (Lattice Semiconductor Board)\n\n\n\nE155 Supplied Boards (Development Board | Adapter Board)"
  },
  {
    "objectID": "appendices.html#hardware-tools",
    "href": "appendices.html#hardware-tools",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "MCU (User Guide | Reference Manual)\n\n\n\nFPGA (Lattice Semiconductor Board)\n\n\n\nE155 Supplied Boards (Development Board | Adapter Board)"
  },
  {
    "objectID": "appendices.html#software-tools",
    "href": "appendices.html#software-tools",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "Software Tools",
    "text": "Software Tools\n\nZoe Worrall Lab Writeups (Lab 1 | Lab 2 | Lab 3 | Lab 4 | Lab 5 | Lab 6 | Lab 7)\n\n\nJordan Carlin Lab Writeups (Lab 1 | Lab 2 | Lab 3 | Lab 4 | Lab 5 | Lab 6 | Lab 7)\n\n\n\n\n\n\n\nImage of Clock Tree\n\n\n\n\n\n\nFigure 13 in the MCU Reference Manual\n\n\n\n\nGithub Link to Project\n\n\nVGA Display Slides by Prof. Brake\n\n\nSnake Game, on which much of our SPI methodology and VGA code was based."
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "The initial goal for this project was to achieve the following:\n\nBuild a system that is able to draw using a joystick controller\nAllow the user to chose between 7 colors to draw with\nGive the user control of the brush’s width (i.e. configure some sort of thickness for the brush)\nAllow the user to pick the brush “off the page” while drawing\nStretch Goal A countdown timer that updates every second\n\nOf these initial goals, we achieved enough for proficiency, but were unable to meet our final specs for the countdown timer. Particularly because of the short at the end, during demo day it was additionally impossible to provide user input.\nIf the project was to be summed in terms of percentage, the following estimates should be made:\n[60%] Transmitting from RAM of the FPGA to a VGA Monitor\n\n[15%] Generating, Transmitting, and Receiving Data via SPI from the MCU to the FPGA board\n\n[10%] Assigning buttons and analog pins, and updating SPI for sending to the FPGA\n\n[10%] Inclusion of a countdown timer\n\n[5%] Additional graphics and presentation of the piece\nOverall, we achieved almost all of our goals, and reached likely 90% of what we wanted to achieve in this project.\n\n\n\n\nThe MCU of the Micro P(ictionary) game used the SystemClock (which runs at 4 MHz) for all calculations.\nThe analog to digital converter on the MCU relies on the output of the AHB Clock. For further details, view the linked clock tree image in the Appendix. This clock ran at at the SystemClock’s speed during this project.\nA new set of modules, STM32L432KC_ADC.c and STM32L432KC_ADC.h, were constructed in order to make for easy initialization of any new ADC pins. The conversion rate of analog to digital signals was not integral to the performance of the system, as we did not anticipate that user input would be changing inputs faster than 10 Hz.\nThe main timing constraint on the MCU side was the control of the sending rate of the SPI. The device is set up to send a new SPI update every 500 ms, based on Timer 12 of the MCU. Because the FPGA would immediately update as soon as it receives its new X and Y direction, the “send rate” of the FPGA also determines the speed with which someone could move the brush on the screen. It was found that the ideal speed to move the brush was 500 ms, but if desired in the future it may be possible to add a potentiometer that increases or decreases the pause time between each update to the brush’s location.\n\n\n\nThe FPGA used a PLL to generate a 50.35 MHz clock derived from the main 48 MHz clock coming from the high speed oscillator. This very specific clock frequency was necessary to accurately generate the H-Sync and V-Sync signals for the VGA monitor. The screen was 800 clocks ticks wide and 525 clock ticks tall, but only 640 by 480 of those are usable pixels. In order to achieve an overall refresh rate of ~60 Hz (which is what the monitor expects), the H-Sync signal needed to run at 31.470 kHz, the V-Sync signal at 59.94 Hz, and the RGB values needed to refresh at 25.175 MHz. While this could all be achieved using a clock speed of 25.175 MHz, the PLL was set to run at double that speed to allow for reads and writes to the SPRAM to occur on alternating clock cycles. This means the VGA RGB values were still changing at 25.175 MHz, but the clock signal was running at 50.35 MHz."
  },
  {
    "objectID": "results.html#quantitative-results",
    "href": "results.html#quantitative-results",
    "title": "Results",
    "section": "",
    "text": "The initial goal for this project was to achieve the following:\n\nBuild a system that is able to draw using a joystick controller\nAllow the user to chose between 7 colors to draw with\nGive the user control of the brush’s width (i.e. configure some sort of thickness for the brush)\nAllow the user to pick the brush “off the page” while drawing\nStretch Goal A countdown timer that updates every second\n\nOf these initial goals, we achieved enough for proficiency, but were unable to meet our final specs for the countdown timer. Particularly because of the short at the end, during demo day it was additionally impossible to provide user input.\nIf the project was to be summed in terms of percentage, the following estimates should be made:\n[60%] Transmitting from RAM of the FPGA to a VGA Monitor\n\n[15%] Generating, Transmitting, and Receiving Data via SPI from the MCU to the FPGA board\n\n[10%] Assigning buttons and analog pins, and updating SPI for sending to the FPGA\n\n[10%] Inclusion of a countdown timer\n\n[5%] Additional graphics and presentation of the piece\nOverall, we achieved almost all of our goals, and reached likely 90% of what we wanted to achieve in this project.\n\n\n\n\nThe MCU of the Micro P(ictionary) game used the SystemClock (which runs at 4 MHz) for all calculations.\nThe analog to digital converter on the MCU relies on the output of the AHB Clock. For further details, view the linked clock tree image in the Appendix. This clock ran at at the SystemClock’s speed during this project.\nA new set of modules, STM32L432KC_ADC.c and STM32L432KC_ADC.h, were constructed in order to make for easy initialization of any new ADC pins. The conversion rate of analog to digital signals was not integral to the performance of the system, as we did not anticipate that user input would be changing inputs faster than 10 Hz.\nThe main timing constraint on the MCU side was the control of the sending rate of the SPI. The device is set up to send a new SPI update every 500 ms, based on Timer 12 of the MCU. Because the FPGA would immediately update as soon as it receives its new X and Y direction, the “send rate” of the FPGA also determines the speed with which someone could move the brush on the screen. It was found that the ideal speed to move the brush was 500 ms, but if desired in the future it may be possible to add a potentiometer that increases or decreases the pause time between each update to the brush’s location.\n\n\n\nThe FPGA used a PLL to generate a 50.35 MHz clock derived from the main 48 MHz clock coming from the high speed oscillator. This very specific clock frequency was necessary to accurately generate the H-Sync and V-Sync signals for the VGA monitor. The screen was 800 clocks ticks wide and 525 clock ticks tall, but only 640 by 480 of those are usable pixels. In order to achieve an overall refresh rate of ~60 Hz (which is what the monitor expects), the H-Sync signal needed to run at 31.470 kHz, the V-Sync signal at 59.94 Hz, and the RGB values needed to refresh at 25.175 MHz. While this could all be achieved using a clock speed of 25.175 MHz, the PLL was set to run at double that speed to allow for reads and writes to the SPRAM to occur on alternating clock cycles. This means the VGA RGB values were still changing at 25.175 MHz, but the clock signal was running at 50.35 MHz."
  },
  {
    "objectID": "results.html#qualitative-results",
    "href": "results.html#qualitative-results",
    "title": "Results",
    "section": "Qualitative Results",
    "text": "Qualitative Results\n\nAnalog Pins\nThe MCU’s use of analog pins was done extremely quickly, in large part thanks to much of the previous work done by past students in Micro P’s. We found the following two sources particularly helpful:\n\nCamera by Kavi Dey, Henry Merrilees, and Neil Chulani\n\nDigital Synthesizer by Kevin Box and Eli Rejto\n\nThe analog pins were capable of measuring the voltage output of the joystick and the potentiometer. It appeared that, especially towards the end, there were conflicts between the sampled data for x, y, and t, with one of the values consistently significantly higher than expected. The analog output of the pins normally measured their input voltage times 1000 when measured correctly; 3.3 volts as a result appeared as 3300 on the board, for example.\n\n\nSPI\n\nThe design was capable of sending two different kinds of SPI packets: either a color bit packet, or a location packet. The color packet was encoded such that it contained configuration bits 111 at the beginning, which could never be reached by x or y location packets because it exceeded the array range being used (Figure 1 and Figure 2).\n\n\n\n\n\n\n\nFigure 1: The bits of color SPI packet.\n\n\n\n\n\n\n\n\n\nFigure 2: The bits of the location SPI packet.\n\n\n\n\nThe system was confirmed to be transmitting via SPI early on during the Mid-semester check-in using oscilloscope traces:\n\n\n\n\n\n\n\n\n\n\n\nWe needed to confirm that the FPGA was properly reaching its desired states based on the incoming SPI packets. This was confirmed using oscilloscope probes attached to the incoming SCK, MOSI, and CS channels and a TEST output pin from the FPGA.\nIn a method similar to that seen in the following images, various states that the FPGA was able to decipher were output to the test pin to check that the SPI packets were being properly received and interpreted.\nAll images are encoded such that Channel 1 is CS, Channel 2 is MOSI, and Channel 3 is SCK.\n\n\n\n\n\n\n\nFigure 3: This image confirms that the SPI packets are carrying accurate data (i.e. the location of the brush) to the FPGA.\n\n\n\n\n\n\n\n\n\nFigure 4: This image uses channel 4, the dark blue channel, to confirm that we were properly reaching a “ready” state within our FSM block diagram. This was set to be true based on the MOSI signal, which it can be seen to match the MOSI signal on Channel 2\n\n\n\n\n\n\nVGA\nThe final system was able to raise the brush up and down, change its color, and move around the screen. From the limited testing that we were able to do, the brush thickness control also appeared to be working. The output image is able to consistently update depending on the color and location inputs. As can be seen in Figure 5, the system was able to create and draw desired images.\n\n\n\n\n\n\nFigure 5: An image depicting our system creating drawings on the screen via the MCU to FPGA communication.\n\n\n\n\nDebugging\nThe following videos show the process of bringing the VGA system out of simulation into the real world.\nFirst, the FPGA was able to output a single hardcoded pixel to the VGA monitor. This version, as we later discovered using the Netlist feature in Lattice Radiant, did not use RAM.\n\n\n\n\n\n\nFigure 6: Video of our planned designated screen on the design with the outline of our block.\n\n\n\nAfter this, we began trying to set the values dynamically according to what was received via the decoded SPI location packets. We confirmed that the write position coordinates (wx and wy) were correct in simulation by checking that when wx and wy were at a set value, for example 100 and 100, and set to 0'b001 (encoding for red), the RAM was recording that value. This was confirmed within the MemoryList feature of ModelSim.\n\n\n\n\n\n\nFigure 7: Video displaying how we were able to finally get some things printing on the FPGA using setting parameters in Lattice Radiant.\n\n\n\nHowever, while displaying this on the screen we ran into an issue; the RAM was not being correctly indexed by the system. It was only possible to alter pixels directly using an address in the matrix.\n\n\n\n\n\n\nFigure 8: A video of trying to read while setting bits according to whats stored in the wx and wy bits at a specific section; these bits should be the color that is stored for a specific location, but when they are sent into the array they don’t update correctly, resulting in the oscillating pattern seen above.\n\n\n\nThis can be seen in the following video (Figure 8), where we tried to set the data within the file to wx and wy while reading out the values. For as of yet still unknown reasons, the data was not being correctly indexed by the RAM. The read logic seemed to be working when the RAM was preloaded, which seemed to indicate the problem was with the write logic, but we were unable to determine the exact cause of the issue.\nAs a result, we moved onto using SPRAM instead instead of the block RAM. SPRAM required that we double the clock speed, but at the same time permitted for better control of what we were sending and receiving to the screen and appropriate updating of the data stored in the RAM. This is where we began to see more expected results.\n\n\n\n\n\n\nFigure 9\n\n\n\nFigure 9 is a demonstration of color being transmitted correctly. With the confirmation of SPI working from earlier, this video confirmed that we were updating colors correctly based on the data received from teh MCU. Our next steps involved filling the entire screen with this data rather than just the noise present in this video.\n\n\n\n\n\n\nFigure 10\n\n\n\nFigure 10 was confirmation that we could control every bit we wanted to using a write x and y of our choosing. From there, it was just a small change to begin moving the pixels about the board with details sent using the other packet for xy bits."
  },
  {
    "objectID": "results.html#the-build",
    "href": "results.html#the-build",
    "title": "Results",
    "section": "The Build",
    "text": "The Build\nOur Final project was made using several bread boards, as well as several laser cut components that give it a finished look. These parts were a breakout board with several color buttons, as well as a casing for a joystick, switch, and potentiometer system.\n\n\n\n\n\n\n\n\nThe joystick circuit as well as the circuitry necessary for the VGA was soldered onto a small protoboard to prevent noise and avoid messy wiring.\nAll seven buttons were put onto a separate bread board to ensure proper circuitry, and were wired in long distance to prevent complex wiring.\nThe switch and the potentiometer were both free floating, but have been given housing that provides easy control for the user when the design is working."
  },
  {
    "objectID": "results.html#final-updates",
    "href": "results.html#final-updates",
    "title": "Results",
    "section": "Final Updates",
    "text": "Final Updates\nUnfortunately, near the very end of the project something went wrong with the physical hardware and the MCU was no longer able to receive data from any of the inputs, digital or analog. This meant that the system was no longer able to take any user input, so drawing was unfortunately no longer possible.\nThe inputs were working until an hour or so before the deadline for this project. Despite them being broken for the actual checkoff, all of the MCU to FPGA communication via SPI and FPGA to VGA monitor communication was working. As a result, images could be displayed as expected. We decided to turn the final version into a “glorified screensaver” for demo day.\n\nThe MCU would randomly generate x and y locations and colors, and from there the rest of the chain would proceed as normal: the MCU encoded the data into SPI packets and transmitted them to the FPGA, which then decoded them, updated the SPRAM, and displayed the constantly changing image on the VGA monitor."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA",
    "section": "",
    "text": "The FPGA controls a VGA monitor and stores the image to be displayed on the monitor. It receives SPI packets from the MCU (see MCU description for an explanation of the packets) that specify what changes need to be made to the image. The current image is stored in SPRAM on the FPGA. As SPI packets are received, there is a block of logic on the FPGA that checks what type of data the packet contains (position or color/brush status) and, if necessary, updates certain pixels in the SPRAM accordingly.\nThe FPGA also has a separate block of logic to drive the actual VGA display. This component scans through each pixel in the SPRAM and sends the appropriate RGB values to the VGA monitor. The pixels are stored in a 3 bit encoding format (one value for each of the 7 colors supported by the system) and a decoder is used to convert these values to the actual 12-bit RGB values for the VGA monitor. The playable area of the screen is 128x128 pixels, so the SPRAM only contains values for those pixels. All pixels outside of this area are set to black. This section of the logic is also responsible for sending the appropriate H-Sync and V-Sync signals to the monitor so it knows when to start a new line or frame of the image.\n\n\n\n\n\n\n\n\nFigure 1: Complete FPGA block diagram\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new). Storing the image in SPRAM is also similar to storing the sbox encoding in a ROM in Lab 7. The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly independent thing, the use of the SPRAM makes that impossible for this project. The VGA driver needs to be able to read from the SPRAM, while the SPI decoder needs to write to it. Additionally, the VGA module can not even directly output the RGB values to the monitor because they need to be looked up in the SPRAM and then decoded. The result of all this intermixing means the VGA module sends just the H-sync and V-sync signals out to the monitor, and sends the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2: Lattice-generated block diagram of the FPGA design.\n\n\n\n\n\n\nOne of the tricky parts of the hardware design for the FPGA was utilizing SPRAM to store the pixel array. There were many attempts to tweak the Verilog to get the synthesis tool to infer the appropriate block block ram hardware. While this was eventually successful, the block ram ended up being insufficient for the project. Writing to it was too inconsistent, and there were severe timing issues. The final design transitioned to using the SPRAM modules instead, which were able to hold sufficient data and functioned as expected when written to.\nThe SPRAM was set up to read on every clock cycle based on the x and y values coming from the VGA controller. The current position data and color was always being sent to the write ports, but the write enable line was hooked up to the brush signal to ensure new colors were only saved when the brush was down.\nThe other main aspect of the hardware design is the actual VGA interface. Figure 3 shows the high-level interface between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 3: Detailed view of FPGA-VGA interface.\n\n\n\nThe colorDecode module itself outputs a total of 12 outputs; three sets of four signals for each of R, G, and B. Each set of four digital output pins is put through a digital to analog converter (DAC), which takes advantage of Kirchoff’s Law and the innate 75 Ohm termination impedance of the VGA monitor. A schematic of the DAC can be seen in Figure 4.\n\n\n\n\n\n\nFigure 4: Digital to Analog Converter used to convert digital signals from the FPGA to analog signals for the VGA monitor.\n\n\n\nThis DAC effectively produced a signal between 0 and 0.7 Volts, which could then be sent out to the VGA, which uses the Voltage to generate the appropriate color."
  },
  {
    "objectID": "fpga.html#block-diagram",
    "href": "fpga.html#block-diagram",
    "title": "FPGA",
    "section": "",
    "text": "Figure 1: Complete FPGA block diagram\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new). Storing the image in SPRAM is also similar to storing the sbox encoding in a ROM in Lab 7. The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly independent thing, the use of the SPRAM makes that impossible for this project. The VGA driver needs to be able to read from the SPRAM, while the SPI decoder needs to write to it. Additionally, the VGA module can not even directly output the RGB values to the monitor because they need to be looked up in the SPRAM and then decoded. The result of all this intermixing means the VGA module sends just the H-sync and V-sync signals out to the monitor, and sends the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2: Lattice-generated block diagram of the FPGA design."
  },
  {
    "objectID": "fpga.html#hardware",
    "href": "fpga.html#hardware",
    "title": "FPGA",
    "section": "",
    "text": "One of the tricky parts of the hardware design for the FPGA was utilizing SPRAM to store the pixel array. There were many attempts to tweak the Verilog to get the synthesis tool to infer the appropriate block block ram hardware. While this was eventually successful, the block ram ended up being insufficient for the project. Writing to it was too inconsistent, and there were severe timing issues. The final design transitioned to using the SPRAM modules instead, which were able to hold sufficient data and functioned as expected when written to.\nThe SPRAM was set up to read on every clock cycle based on the x and y values coming from the VGA controller. The current position data and color was always being sent to the write ports, but the write enable line was hooked up to the brush signal to ensure new colors were only saved when the brush was down.\nThe other main aspect of the hardware design is the actual VGA interface. Figure 3 shows the high-level interface between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 3: Detailed view of FPGA-VGA interface.\n\n\n\nThe colorDecode module itself outputs a total of 12 outputs; three sets of four signals for each of R, G, and B. Each set of four digital output pins is put through a digital to analog converter (DAC), which takes advantage of Kirchoff’s Law and the innate 75 Ohm termination impedance of the VGA monitor. A schematic of the DAC can be seen in Figure 4.\n\n\n\n\n\n\nFigure 4: Digital to Analog Converter used to convert digital signals from the FPGA to analog signals for the VGA monitor.\n\n\n\nThis DAC effectively produced a signal between 0 and 0.7 Volts, which could then be sent out to the VGA, which uses the Voltage to generate the appropriate color."
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Meet the Team",
    "section": "",
    "text": "email:   jcarlin@g.hmc.edu \n\n\nJordan Carlin is a junior engineering major at Harvey Mudd College interested in computer engineering and digital design. He is currently doing research as a Clay-Wolkin Fellow at Harvey Mudd’s VLSI lab working on a superscalar implementation of the open-source OpenHW-Group CVW RISC-V SoC. He has experience with SystemVerilog and RISC-V assembly and would love to continue growing his computer engineering skills. He’s always excited to learn new things and would be happy to connect with you!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n LinkedIn \n\n\n\n GitHub \n\n\n Website \n\n\n OpenHW Github"
  },
  {
    "objectID": "team.html#jordan-carlin",
    "href": "team.html#jordan-carlin",
    "title": "Meet the Team",
    "section": "",
    "text": "email:   jcarlin@g.hmc.edu \n\n\nJordan Carlin is a junior engineering major at Harvey Mudd College interested in computer engineering and digital design. He is currently doing research as a Clay-Wolkin Fellow at Harvey Mudd’s VLSI lab working on a superscalar implementation of the open-source OpenHW-Group CVW RISC-V SoC. He has experience with SystemVerilog and RISC-V assembly and would love to continue growing his computer engineering skills. He’s always excited to learn new things and would be happy to connect with you!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n LinkedIn \n\n\n\n GitHub \n\n\n Website \n\n\n OpenHW Github"
  },
  {
    "objectID": "team.html#zoe-worrall",
    "href": "team.html#zoe-worrall",
    "title": "Meet the Team",
    "section": "Zoe Worrall",
    "text": "Zoe Worrall\n\n email:   zworrall@g.hmc.edu \n\nMae g’ovannen! My name is Zoe Worrall, and I am currently a senior Engineering Major at Harvey Mudd College.\nAlthough I have experience with a broad range of engineering topics including materials engineering, continuum mechanics, and manufacturing, my primary interests lie in signal processing, radio frequency, and optical systems.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Micro P’s Website \n\n\n\n LinkedIn \n\n\n\n GitHub"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "Micro P(ictionary)",
    "section": "Abstract",
    "text": "Abstract\nWelcome to MicroP(ictionary)!\nThis design project sought to create a Pictionary-like device using an UPduino iCE40 UP5K FPGA board and an STM32L432KC MCU board. Pictionary is a game where one player draws an image and the other player has to guess what is being drawn in a set amount of time. Micro P(ictionary) takes this into the digital world and allows a user to control an on screen brush to “draw” on a screen. The player is able to manipulate the brush’s size, color, and location in order to draw whatever designs they want. This is accomplished using a system of seven buttons for color, a potentiometer to control the size of the brush, a switch to control whether the brush was up or down, and a joystick to control the brush’s location on the screen.\nThe design uses an MCU and an FPGA to control a VGA monitor. The MCU reads 11 real-time inputs from a user, including both analog and digital signals, and sends SPI packets to the FPGA board. The FPGA interprets the incoming SPI packets, and uses them to manipulate a brush on the VGA screen using a set of digital to analog converters which control red, green, and blue signals.\n\n\n\n\n\n\nFigure 1: Top level block diagram of the complete system.\n\n\n\nBy the end of the project, the device was capable of drawing on the screen and displaying a variety of colors. It had also previously demonstrated its ability to draw and control if the brush was up or down using the inputs of the MCU controller. This was captured in a photograph (Figure 2).\n\n\n\n\n\n\nFigure 2: A photograph captured of the working Micro P(ictionary) program. The user was able to pick the brush up and place it down, change color and size of the brush, and move the brush to the desired locations on the screen.\n\n\n\nHowever, roughly an hour before the end of the project, while trying to reconfigure some of the analog components to decrease the noise seen in the circuit, part of the board was shorted out. As a result, last minute changes were made to showcase the VGA display to others. Updated code removed the ability for the user to input data into the MCU. The MCU instead randomly generated signals which were then sent to the VGA display using the same encoding as would have applied for analog circuitry. This was dubbed a “glorified screensaver” for observers.\n\n\n\n\n\n\nFigure 3: Video of the glorified screen saver while running for Demo Day. Uses the same communication and decoding methods as the initial function, but there is a randomly generated set of positions and colors being sent from the MCU.\n\n\n\nThe Github repository included in this report has two branches: main, which contains the current FPGA and MCU code for what was used in order to get the device actually functioning before the board was shorted, and random-display that demonstrates what was shown during the device’s Demo Day.\nThis report will detail\n\nDetails on the layout of the MCU\n\nDetails on the layout of the FPGA\n\nDetails on the hardware\n\nDetails on results\n\nDetails on the team behind this project"
  },
  {
    "objectID": "index.html#project-overview",
    "href": "index.html#project-overview",
    "title": "Micro P(ictionary)",
    "section": "Project Overview",
    "text": "Project Overview\nMicroP(ictionary) is a game for lab students that want to play Pictionary online, but have to play using hardware instead. The goal of this project was to make a Micro P(ictionary) game with the following specs:\n\n7 Buttons to control 7 different colors\nA potentiometer to control the thickness of the brush being used\nA brush up/down switch that controls whether the brush is drawing or not\nA joystick to control where we are on the board.\n\nThe project had two separate pieces; the MCU that collects and stores the current status of the brush (thickness and location), and the FPGA, which has an onboard RAM that stores the color left behind by the brush or simply shows the user their current location. The brush will always be orange. The MCU consistently sends SPI updates of the location of the user to the FPGA board, and the FPGA board then outputs this data onto the computer screen. When the user updates the color of the brush or decides to put the brush down, the system sends an additional SPI packet with the updated color and brush up/down information.\nPrior to this issue, the device was able to draw x/y locations, as well as travel in a controlled manner about the screen.\nA video prior to this was not captured demonstrating how the brush was able to travel about the screen and leave a trail: this video, however, displays how the brush’s current color was being captured and making it over to the VGA device, and how control of whether the color was changed via the brush up/down switch was changed.\n\nThe overview of this system can be seen in Figure 1."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Breaking down this design from the top down, the system takes user input, processes it within the MCU, and then updates the FPGA with the brush’s current location and any updated color settings using SPI. The entire 128x128 grid used for drawing is stored on the FPGA within its RAM memory, and the SPI updates are used in order to read into the device and write out. Depending on if the brush is raised or lowered, the FPGA will follow different logic; when the brush moves, it will either leave the previous color behind, or it will update the color with the current color selected by the brush.\n\n\n\n\n\n\nFigure 1: Simplified Block diagram of the system’s interconnects.\n\n\n\nPrior to completing the entire design, we figured out what pins could be used on the MCU board to determine exactly how many colors and controls we could have. We started by figuring out which pins we would use for SPI, as the Development Board used in E155 hardwires them together. We found that with our current break-out board, and with the assumption that the colors would be set using interrupt controls, we could use seven pins off of the MCU. We further determined which three pins we could use for analog input, and assigned our final pin for brush up and brush down using the only remaining pin.\nThe FPGA board’s pins were routed based off of the number of pins necessary to control the VGA’s red, blue, and green channels, as well as whether the V-Sync and H-Sync of the VGA was on or off. For further details on how VGA works, see the FPGA Section or this website.\nThis design resulted in the following overall schematic for the board interconnects (Figure 2), although further details and decisions can be found in the MCU Section and the FPGA Section.\n\n\n\n\n\n\nFigure 2: Detailed schematic diagram of hardware used within the project."
  },
  {
    "objectID": "documentation.html#schematics",
    "href": "documentation.html#schematics",
    "title": "Documentation",
    "section": "",
    "text": "Breaking down this design from the top down, the system takes user input, processes it within the MCU, and then updates the FPGA with the brush’s current location and any updated color settings using SPI. The entire 128x128 grid used for drawing is stored on the FPGA within its RAM memory, and the SPI updates are used in order to read into the device and write out. Depending on if the brush is raised or lowered, the FPGA will follow different logic; when the brush moves, it will either leave the previous color behind, or it will update the color with the current color selected by the brush.\n\n\n\n\n\n\nFigure 1: Simplified Block diagram of the system’s interconnects.\n\n\n\nPrior to completing the entire design, we figured out what pins could be used on the MCU board to determine exactly how many colors and controls we could have. We started by figuring out which pins we would use for SPI, as the Development Board used in E155 hardwires them together. We found that with our current break-out board, and with the assumption that the colors would be set using interrupt controls, we could use seven pins off of the MCU. We further determined which three pins we could use for analog input, and assigned our final pin for brush up and brush down using the only remaining pin.\nThe FPGA board’s pins were routed based off of the number of pins necessary to control the VGA’s red, blue, and green channels, as well as whether the V-Sync and H-Sync of the VGA was on or off. For further details on how VGA works, see the FPGA Section or this website.\nThis design resulted in the following overall schematic for the board interconnects (Figure 2), although further details and decisions can be found in the MCU Section and the FPGA Section.\n\n\n\n\n\n\nFigure 2: Detailed schematic diagram of hardware used within the project."
  },
  {
    "objectID": "documentation.html#new-hardware",
    "href": "documentation.html#new-hardware",
    "title": "Documentation",
    "section": " New Hardware ",
    "text": "New Hardware \n\nMicro P(ictionary) is built using the FPGA and MCU programming techniques and skills learned throughout Mudd’s E155 course, with several new hardware and software components.\n\n Joystick \nFor the MCU, alongside the interrupts and SPI outputs from previous labs, new analog functionality was included in order to allow for joystick control and the use of a potentiometer for brush size. The joystick that we chose outputs an analog voltage for x and y on two different pins; depending on the incoming voltage, the joystick will output half the voltage in its middle state, 0 at its lowest, and the full applied voltage at its highest. In our design, we powered the joystick under its required supply voltage of 5 V at 3.3 V, meaning that when powered, the joystick would output about 1.7 V at medium power, 3.3 V at max (either positive X or Y), and 0 V for lowest power (either negative X or Y). Each analog input needs to be read into the MCU using the onboard ADCs and then filtered to give us usable data to determine the desired position for the brush. The same idea applied for the potentiometer.\n\n\n VGA  (Video Graphics Array) \nThe other significant new hardware component is the VGA monitor. This required lots of new components of the FPGA. First of all, the PLL was needed to generate the clock signal to produce the H-Sync and V-Sync signals for the monitor. This also required the use of a much larger RAM (an SPRAM in this case) to store the color data for each pixel. This RAM in particular was the source of many of our troubles throughout this project.\nThe VGA requires an analog input to all three pins used for color (i.e. R-G-B pins). This meant that in addition to the code that was constructed in Lattice Radiant, we needed to make a physical digital to analog (DAC) converter, with seven resistors used for each channel.\n\n\nAdditional Hardware Information\nFor more details on the hardware, see the MCU and FPGA pages. These include schematics and block diagrams.\nThe Github repository contains all of the source code for the project.\nRelevant links for more information can be found in the Appendix.\nThis project has a relatively low barrier of entry from a hardware perspective. If you are working from a well stocked lab, the only parts that are not likely present are the joystick and a VGA breadboard adapter."
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\n\n\n\n\n\n\nItem\nPart Number\nQuantity\nTotal Price\n\n\n\n\nVGA Adapter\nVGA DB15\n1\n$7.39\n\n\nJoystick\nKY-023\n5\n$6.49\n\n\nVGA Monitor\nAny\n1\nDigital Lab\n\n\nDIP Button\nSPST-NO\n1\nStockroom\n\n\nDIP Switch\n782-3831-5-ND\n1\nStockroom\n\n\n10 kOhm Potentiometer\nAlpha B10k\n1\nStockroom\n\n\nDIP Switch\n72N3906\n1\nStockroom"
  }
]