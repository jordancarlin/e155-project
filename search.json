[
  {
    "objectID": "appendices.html",
    "href": "appendices.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "This is a website for Jordan and Zoe’s final project. More details to come soon!\nMidpoint report: A 4-page report (plus appendices) documenting your design at the midpoint. Your report should be submitted before your scheduled checkpoint slot. The status report should include:\nSchematics of anything on a breadboard, Block diagrams of the logic on your FPGA, An outline of the routines used on the MCU. You should include as an appendix either your Verilog code or software that is mostly complete (but do not have to have both ready). You must be ready to demonstrate some working hardware in the lab.\nProficiency\n\nClear and concise written summary of current status [] Schematics of all breadboarded circuits [] Block diagram of system components and the interfaces between them [] Hardware demo functioning (potentially with some minor bugs) [] More than 25% of the way to the final deliverable [] Clear description of microcontroller routines [] All external parts ordered\n\nExcellence\n[] All interfaces in the block diagram defined (e.g., SPI, I2C, GPIO) [] Hardware demo functioning well [] Writing is well organized [] Solid grammar or spelling issues (no more than a few minor errors which do not detract from the point). [] Completed riskiest element of the project [] More than 50% of the way to the final deliverable"
  },
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU",
    "section": "",
    "text": "The multicore processor in this project is used to keep track of the current brush state, the color state, the thickness of the brush, and whether the brush is up or down. The system collects this data and then sends it to the FPGA board for VGA processing via a SPI package. There are two primary SPI packages used to communicate the status of bits, and they are organized such that the header of the color SPI block is easily distinguished and decoded.\n\n\nThe MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\nThe hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly.\n\n\n\n\nWe are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "mcu.html#schematic",
    "href": "mcu.html#schematic",
    "title": "MCU",
    "section": "",
    "text": "The MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "mcu.html#hardware",
    "href": "mcu.html#hardware",
    "title": "MCU",
    "section": "",
    "text": "The hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly."
  },
  {
    "objectID": "mcu.html#current-status",
    "href": "mcu.html#current-status",
    "title": "MCU",
    "section": "",
    "text": "We are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "This is a website for Jordan and Zoe’s Pictionary Project.\nMidpoint report: A 4-page report (plus appendices) documenting your design at the midpoint. Your report should be submitted before your scheduled checkpoint slot. The status report should include:\nSchematics of anything on a breadboard, Block diagrams of the logic on your FPGA, An outline of the routines used on the MCU. You should include as an appendix either your Verilog code or software that is mostly complete (but do not have to have both ready). You must be ready to demonstrate some working hardware in the lab.\nProficiency\n\nClear and concise written summary of current status [] Schematics of all breadboarded circuits [] Block diagram of system components and the interfaces between them [] Hardware demo functioning (potentially with some minor bugs) [] More than 25% of the way to the final deliverable [] Clear description of microcontroller routines [] All external parts ordered\n\nExcellence\n[] All interfaces in the block diagram defined (e.g., SPI, I2C, GPIO) [] Hardware demo functioning well [] Writing is well organized [] Solid grammar or spelling issues (no more than a few minor errors which do not detract from the point). [] Completed riskiest element of the project [] More than 50% of the way to the final deliverable"
  }
]