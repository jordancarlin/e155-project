[
  {
    "objectID": "appendices.html",
    "href": "appendices.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "Midpoint report: A 4-page report (plus appendices) documenting your design at the midpoint. Your report should be submitted before your scheduled checkpoint slot. The status report should include:\nSchematics of anything on a breadboard, Block diagrams of the logic on your FPGA, An outline of the routines used on the MCU. You should include as an appendix either your Verilog code or software that is mostly complete (but do not have to have both ready). You must be ready to demonstrate some working hardware in the lab.\nProficiency\n\nClear and concise written summary of current status [] Schematics of all breadboarded circuits [] Block diagram of system components and the interfaces between them [] Hardware demo functioning (potentially with some minor bugs) [] More than 25% of the way to the final deliverable [] Clear description of microcontroller routines [] All external parts ordered\n\nExcellence\n[] All interfaces in the block diagram defined (e.g., SPI, I2C, GPIO) [] Hardware demo functioning well [] Writing is well organized [] Solid grammar or spelling issues (no more than a few minor errors which do not detract from the point). [] Completed riskiest element of the project [] More than 50% of the way to the final deliverable"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jordan and Zoe E155 Final Project",
    "section": "",
    "text": "This is a website for Jordan and Zoe’s Pictionary Project."
  },
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU",
    "section": "",
    "text": "The multicore processor in this project is used to keep track of the current brush state, the color state, the thickness of the brush, and whether the brush is up or down. The system collects this data and then sends it to the FPGA board for VGA processing via a SPI package. There are two primary SPI packages used to communicate the status of bits, and they are organized such that the header of the color SPI block is easily distinguished and decoded.\n\n\nThe MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\nThe hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly.\n\n\n\n\nWe are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "mcu.html#schematic",
    "href": "mcu.html#schematic",
    "title": "MCU",
    "section": "",
    "text": "The MCU makes use of many of the materials and ideas seen throughout the semester in MicroP’s so far. It uses interrupts in order to map out the current color, with a total of seven potential colors (including erase). The system also implements the newer technology of Analog reading, which is used to determine the current state of a joystick for location control, as well as a potentiometer to control the thickness of the brush at any given time (ranging from 1x1 to 2x2 to 3x3).\n\nThe program starts first by initializing all of its components before entering a while loop, which controls the main functions required of the MCU. This while loop delays for some predetermined amount of time, before calling read_XY to find the current state of the joystick and to update the size of brush.\nThis information is used to determine what SPI packages are sent at the end of the while loop.\nThe block diagram below (Figure 1) depicts the general variables and assignments used within the MCU program.\n\n\n\n\n\n\nFigure 1\n\n\n\nThis can be expounded upon to show what exactly is happening within the program (Figure 2).\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "mcu.html#hardware",
    "href": "mcu.html#hardware",
    "title": "MCU",
    "section": "",
    "text": "The hardware for the board has arrived and has been implemented on a breadboard. Future plans encompass adding larger buttons for the DIP Buttons, as well as potentially building a controller that will allows the user to control many items at once with little concern for messing up wiring.\nCurrently, the program is able to send out all the locations necessary dependent on which thickness the current brush is. This can be seen in the set of images below:\n\n\n\n\n\n\n\n\n\n\n\nThe files are sent in this way to ensure the simplest possibe implementation on the FPGA. The FPGA board currently uses combinational logic to interpret the incoming SPI data, and as a result, by sending each pixel that should be currently turned on, the MCU prevents the FPGA from needing to use a finite state machine in order to interpret the data it is placing in the RAM at any given.\nIn addition, when a button is pressed, the color_spi spi packet is sent along with the location data, which contains information on whether the brush is down or up, as well as what color the current SPI bus is.\nThe maximum possible number of SPI packets sent in a given round is 10 (each SPI packet is considered to be to collections of 8 bits), and the minimum is 1.\nA “SPI Packet”, as we have deemed, can be of two types:\n\n\n\n\n\n\n\nThese SPI are differentiated by the first three bits of the SPI message: in the case of color_spi, the first three bits will always make the value of the character greater than 200, which is an impossible for the x and y indeces to be. As a result, the SPI blocks can be easily differentiated with the use of the first three bits, which the FPGA will figure out combinationally and will then use to adjust its values accordingly."
  },
  {
    "objectID": "mcu.html#current-status",
    "href": "mcu.html#current-status",
    "title": "MCU",
    "section": "",
    "text": "We are currently able to perform all necessary functions required for the final prototype, and mainly now need to configure the SPI connection and performance of the FPGA. As it stands, this video demonstrates the readouts of the board, as well as a representation of the data it will be sending to the FPGA board, at any given point in time. When the timer is replaced with a much shorter one, these updates will be sent at a frequency of roughly 1 kHz, although we will vary this depending on what we decide works best for timing on the FPGA."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA",
    "section": "",
    "text": "The FPGA controls drives a VGA monitor and stores the image to be displayed on the monitor. It recieves SPI packets from the MCU (see MCU description for an explanation of the packets) that specify what changes need to be made to the image. The current image is stored in block ram on the FPGA. As SPI packets are received, there is a block of logic on the FPGA that checks what type of data the packet contains and, if necessary, updates certain pixels in the block ram accordingly.\nThe FPGA also has a block of sequential to drive the actual VGA display that scans through each pixel in the block ram and sends the appropriate RGB values to the VGA monitor. The pixels are stores in a 3 bit encoding format (one value for each of the 7 colors supported by the system) and a decoder is used to convert these values to the actual RGB values for the VGA monitor. The playable area of the screen is 200x200 pixels, so the block ram only contains values for those pixels.\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new) and the use of block ram to store the image is also similar to storing the sbox encoding in Lab 7 (though this one needs to be a writable ram instead of just a pre-loaded rom). The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly indepenent thing, the use of the block ram makes that impossible for this project. The VGA driver needs to be able to read from the block ram, while the SPI decoder needs to write to it. Additionally, the VGA module isn’t even able to directly output the RGB values to the monitor becaue they need to be looked up in the block ram and then decoded. This means the VGA module sends most of the VGA signals out to the monitor, but send the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\nOne of the tricky parts of the hardware design for the FPGA was utilizing block ram to store the pixel array. There were many attempts to tweak the verilog to get the synthesis tool to infer the appropriate block ram hardware. As seen in Figure 3, this was eventually successful and it is utilizing a block ram that reads combinationally (though is sequenced by a flop) and writes sequentially on the rising edge of the clock. The write enable line also had to be connected to data recieved from the SPI packets to ensure pixels were only updated when the pen was down.\n\n\n\n\n\n\nFigure 3\n\n\n\nThe other main aspect of the hardware design is the actual VGA interface. Figure 4 shows the high-level interace between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\n\nA second version of all of the Verilog is written and (almost) passing synthesis. The inital version that was designed had to scrapped because the hierarchy and interfaces between each module were woefully insufficient. A new block diagram (Figure 1) was created with a far shallower hierarchy to allow for more communication between modules. The old design for the pixel array was also not being detected properly as a RAM. The current version is being detected as a block RAM with the expected read, write, and enable ports.\nThe current design passes the first few stages of synthesis, but is currently running into issues with place and route and with timing. The timing issues likely stem from clock issues becasue the SPI sck needs to drive some of the design while the VGA vgaclk needs to drive other parts of it. Using multiple clocks is far from ideal, but is necessary because of the strict timing requirements for VGA monitors. The place and route issues likely stem from the timing problems, but it is not possible to know for sure until the timing issues are resolved.\nThe other part of the FPGA process that is currently underway is verification of the design. Testbenches are in their early stage of creation and will be used to verify the SPI half of the design and the VGA half of the design separately. Depending on how those go, a full system testbench will likely be created to verify the entire design."
  },
  {
    "objectID": "fpga.html#block-diagram",
    "href": "fpga.html#block-diagram",
    "title": "FPGA",
    "section": "",
    "text": "Figure 1\n\n\n\nThe FPGA design builds heavily upon what was done in Lab 7 in MicroPs. It uses a similar design for the SPI module itself (although the decoder is entirely new) and the use of block ram to store the image is also similar to storing the sbox encoding in Lab 7 (though this one needs to be a writable ram instead of just a pre-loaded rom). The most significant new part of this design is the VGA driver itself.\nAs pictured in Figure 1, many of the modules in this design are heavily intertwined. While ideally each module is a mostly indepenent thing, the use of the block ram makes that impossible for this project. The VGA driver needs to be able to read from the block ram, while the SPI decoder needs to write to it. Additionally, the VGA module isn’t even able to directly output the RGB values to the monitor becaue they need to be looked up in the block ram and then decoded. This means the VGA module sends most of the VGA signals out to the monitor, but send the x and y values to rest of the system for further processing before the RGB values are sent to the monitor. This significantly complicates the timing for the design and makes unit level testbenches difficult to design. The heavily interwoven modules can be seen most clearly in the generated block diagram from Lattice in Figure 2.\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "fpga.html#hardware",
    "href": "fpga.html#hardware",
    "title": "FPGA",
    "section": "",
    "text": "One of the tricky parts of the hardware design for the FPGA was utilizing block ram to store the pixel array. There were many attempts to tweak the verilog to get the synthesis tool to infer the appropriate block ram hardware. As seen in Figure 3, this was eventually successful and it is utilizing a block ram that reads combinationally (though is sequenced by a flop) and writes sequentially on the rising edge of the clock. The write enable line also had to be connected to data recieved from the SPI packets to ensure pixels were only updated when the pen was down.\n\n\n\n\n\n\nFigure 3\n\n\n\nThe other main aspect of the hardware design is the actual VGA interface. Figure 4 shows the high-level interace between the FPGA and the VGA monitor. The VGA and colorDecode modules drive these signals, with the colorDecode module driving the R, G, and B signals and all of the timing and sync signals coming from the VGA module.\n\n\n\n\n\n\nFigure 4"
  },
  {
    "objectID": "fpga.html#current-status",
    "href": "fpga.html#current-status",
    "title": "FPGA",
    "section": "",
    "text": "A second version of all of the Verilog is written and (almost) passing synthesis. The inital version that was designed had to scrapped because the hierarchy and interfaces between each module were woefully insufficient. A new block diagram (Figure 1) was created with a far shallower hierarchy to allow for more communication between modules. The old design for the pixel array was also not being detected properly as a RAM. The current version is being detected as a block RAM with the expected read, write, and enable ports.\nThe current design passes the first few stages of synthesis, but is currently running into issues with place and route and with timing. The timing issues likely stem from clock issues becasue the SPI sck needs to drive some of the design while the VGA vgaclk needs to drive other parts of it. Using multiple clocks is far from ideal, but is necessary because of the strict timing requirements for VGA monitors. The place and route issues likely stem from the timing problems, but it is not possible to know for sure until the timing issues are resolved.\nThe other part of the FPGA process that is currently underway is verification of the design. Testbenches are in their early stage of creation and will be used to verify the SPI half of the design and the VGA half of the design separately. Depending on how those go, a full system testbench will likely be created to verify the entire design."
  }
]